# JavaScript高级程序设计

# 1、什么是JavaScript

* JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。
  * ECMAScript:由ECMA-262定义并提供核心功能。
  * 文档对象模型(DOM):提供与**网页内容**交互的方法和接口。
  * 浏览器对象模型（BOM):提供与**浏览器**交互的方法和接口。
* JavaScript的这三个部分得到了五大Web浏览器(正、Firefox、Chrome、Safari和Opera)不同程度的支持。所有浏览器基本上对ES5(ECMAScript 5)提供了完善的支持，而对ES6(ECMAScript 6)和ES7 (ECMAScript7)的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Leve13的支持日益趋于规范。HTML5中收录的BOM 会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。



# 2、HTML中的JavaScript

* 要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。
* 所有< script>元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在< script>元素中的代码必须严格按次序解释。
* 对不推迟执行的脚本，浏览器必须解释完位于< script>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把< script>元素放到页面末尾，介于主内容之后及< /body>标签之前。
* 可以**使用defer 属性把脚本推迟到文档渲染完毕后再执行**。推迟的脚本原则上按照它们被列出的次序执行。
* 可以**使用async属性表示脚本不需要等待其他脚本**，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
* 通过**使用< noscript>元索，可以指定在浏览器不支持脚本时显示的内容**。如果浏览器支持并启用脚本，则< noscript>元素中的任何内容都不会被渲染。



# 3、语言基础

* 严格模式

~~~JavaScript
function doSomething(){
    "use strict";
    //函数体
}
~~~

* **var/let/const：**

~~~js
//1、var函数作用域 函数的局部变量
function test1(){
    var message = "hi";//局部变量
}
test1();
console.log(message);//出错

//省略var 全局变量 不推荐
function test2(){
    message = "hi";
}
test2();
console.log(message)//"hi"

//2、var变量提升 把所有变量声明都拉到函数作用域的顶部

//let块作用域
if(true){
    let age = 26;
    console.log(age);//26
}
console.log(age)//age没有定义

//1、暂时性死区 let声明的变量不会在作用域中被提升
//2、var声明的变量会成为window对象的属性，let不会
//3、条件声明 不检查是否已声明
//4、let之前，for循环定义的迭代变量会渗透到循环体外部

//const 的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误
~~~

* Number( )函数基于如下规则执行转换:布尔值，true转换为1， false转换为0;数值，直接返回;null，返回0;undefined，返回NaN;字符串，应用规则。

* ECMAScript中的基本数据类型包括Undefined、Null、Boolean 、Number(不区分整数和浮点值) 、String 和Symbol;Object是一种复杂数据类型，它是这门语言中所有对象的基类。
* ECMAScript提供了C语言和类C语言中常见的很多基本操作符,包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。
* ECMAScript中的函数与其他语言中的函数不一样。不指定返回值的函数实际上会返回特殊值undefined。



# 4、变量、作用域与内存

* JavaScript变量可以保存两种类型的值:原始值和引用值。原始值可能是以下6种原始数据类型之一:Undefined、Null、Boolean、Number、String和symbol。原始值和引用值有以下特点。
* 原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。
* 引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
* typeof操作符可以确定值的原始类型，而instanceof操作符用于确保值的引用类型。
* 任何变量（不管包含的是原始值还是引用值)都存在于某个执行上下文中(也称为作用域)。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文分全局上下文、函数上下文和块级上下文。
* 代码执行流每进入一个新**上下文**，都会创建一个作用域链，用于搜索变量和函数。函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。变量的执行上下文用于确定什么时候释放内存。
* JavaScript是使用**垃圾回收**的编程语言，离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
* **引用计数**是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的正仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素)。引用计数在代码中存在循环引用时会出现问题。
* **解除变量的引用**不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。



# 5、基本引用类型

* 引用值与传统面向对象编程语言中的类相似，但实现不同。ECMAScript **缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口**。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
* Date类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。
* RegExp类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。存在**模式局限**(分别匹配字符串的开始和末尾、条件式匹配、正则表达式注释)。
* JavaScript 比较独特的一点是，**函数实际上是Function类型的实例，也就是说函数也是对象**。因为函数也是对象，所以函数也有方法，可以用于增强其能力。
* 由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有3种原始值包装类型:Boolean、Nurmber和 string。它们都具备如下特点。
  * 每种包装类型都映射到同名的原始类型。
  * 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。
  * 涉及原始值的语句执行完毕后，包装对象就会被销毁。
* 当代码开始执行时，全局上下文中会存在两个内置对象:Global和 Math。其中，Global对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为window对象。所有全局变量和函数都是Global对象的属性。Math对象包含辅助完成复杂计算的属性和方法。



# 6、集合引用类型

* JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。引用类型与传统面向对象编程语言中的类相似，但实现不同。
* Object类型是一个基础类型，所有引用类型都从它继承了基本的行为。
* Array类型表示一组有序的值，并提供了操作和转换值的能力。
* 定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。
* ECMAScript6新增了一批引用类型:Map、weakMap、Set和 weakSet。这些类型为组织应用程序数据和简化内存管理提供了新能力。



# 7、迭代器与生成器

* ECMAScript 6正式支持迭代模式并引入了两个新的语言特性:迭代器和生成器。迭代会在一个**有序集合**上进行。(“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是JavaScript中有序集合的最典型例子。
* 迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现itarable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现iterator接口的对象。
* 迭代器必须通过连续调用**naxt()**方法才能连续取得值，这个方法返回一个**Iteratorobject**。这个对象包含一个done 属性和一个value 属性。前者是一个布尔值，表示是否还有更多值可以访问;后者包含迭代器返回的当前值。这个接口可以通过手动反复调用next ()方法来消费，也可以通过原生消费者，比如for-of循环来自动消费。
* 生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了Iterable接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield关键字，这个关键字能够暂停执行生成器函数。使用yield关键字还可以通过next()方法接收输人和产生输出。在加上星号之后，yield关键字可以将跟在它后面的可迭代对象序列化为一连串值。



# 8、对象、类与面向对象编程

* 属性的类型:
  * 数据属性
    * `Configurable`：是否可以通过delete删除并重新定义，是否可以修改它的特性，是否可以把它改为访问器属性
    * `Enumerable`：是否可以通过for-in循环返回
    * `Writable`：表示属性的值是否可以被修改
    * `Value`：包含属性实际的值
  * 访问器属性
    * `Configurable`：是否可以通过delete删除并重新定义，是否可以修改它的特性，是否可以把它改为访问器属性
    * `Enumerable`：是否可以通过for-in循环返回
    * `Get`：获取函数，读取属性时调用
    * `Set`：设置函数，写入属性时调用
* 对象解构赋值 ：嵌套解构、部分解构、参数上下文匹配
* 对象在代码执行过程中的任何时候都可以被创建和增强(mixin)，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。
  * **工厂模式**就是一个简单的函数**(creatxxx)**，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。
  * 使用**构造函数模式**可以自定义引用类型，可以使用**new关键字**像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。
  * **原型模式**解决了成员共享的问题，只要是添加到构造函数**prototype** 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。
* 对象迭代：Object.values()(返回对象值)和Object.entries()(返回键/值)接受一个对象，返回它们内容的数组。
* JavaScript 的**继承**主要通过**原型链**来实现。**原型链涉及把构造函数的原型赋值为另一个类型的实例**。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。
* **盗用构造函数模式**通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义(因为子类不能访问父类原型上的方法)。
* 目前最流行的继承模式是**组合继承**，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。
* 除上述模式之外，还有以下几种继承模式。
  * 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。
  * 与原型式继承紧密相关的是**寄生式继承**，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。
  * **寄生组合继承**被认为是实现基于类型继承的最有效方式。
* ECMAScript 6新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。



# 9、代理与反射

* 代理是ECMAScript 6新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的JavaScript元编程及抽象的新天地。
* 从宏观上看，代理是真实JavaScript对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从**捕获器不变式**。(target,handler)
* 与代理如影随形的反射API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把**反射**API看作一套基本操作，这些操作是绝大部分JavaScript对象API的基础。(Refelct)
* 代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如(但远远不限于)跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。



# 10、函数

* 函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。
* ES6新增了类似于函数表达式的箭头函数语法，但两者也有一些重要区别。(箭头函数不能使用arguments，super和new.target，也不能做构造函数。箭头函数也没有prototype属性)
* JavaScript中函数定义与调用时的参数极其灵活。arguments对象,以及ES6新增的扩展操作符，可以实现函数定义和调用的完全动态化。
* 函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。
* JavaScript引擎可以优化符合尾调用条件的函数，以节省栈空间。
* 闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。
* 通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。
* 闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。
* 函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。
* 立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。
* 虽然JavaScript没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。
* 可以访问私有变量的公共方法叫作特权方法。
* 特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。



# 11、期约与异步函数

* 长期以来，掌握单线程JavaScript运行时的异步行为一直都是个艰巨的任务。随着ES6新增了期约和ES8新增了异步函数，ECMAScript 的异步编程特性有了长足的进步。通过期约和 async/await，不仅可以实现之前难以实现或不可能实现的任务，而且也能写出更清晰、简洁,并且容易理解、调试的代码。
* 期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。
* 异步函数是将期约应用于JavaScript 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代JavaScript工具箱中最重要的工具之一。
