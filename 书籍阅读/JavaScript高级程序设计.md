# JavaScript高级程序设计

# 1、什么是JavaScript

* JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。
  * ECMAScript:由ECMA-262定义并提供核心功能。
  * 文档对象模型(DOM):提供与**网页内容**交互的方法和接口。
  * 浏览器对象模型（BOM):提供与**浏览器**交互的方法和接口。
* JavaScript的这三个部分得到了五大Web浏览器(正、Firefox、Chrome、Safari和Opera)不同程度的支持。所有浏览器基本上对ES5(ECMAScript 5)提供了完善的支持，而对ES6(ECMAScript 6)和ES7 (ECMAScript7)的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Leve13的支持日益趋于规范。HTML5中收录的BOM 会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。



# 2、HTML中的JavaScript

* 要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。
* 所有< script>元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在< script>元素中的代码必须严格按次序解释。
* 对不推迟执行的脚本，浏览器必须解释完位于< script>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把< script>元素放到页面末尾，介于主内容之后及< /body>标签之前。
* 可以**使用defer 属性把脚本推迟到文档渲染完毕后再执行**。推迟的脚本原则上按照它们被列出的次序执行。
* 可以**使用async属性表示脚本不需要等待其他脚本**，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
* 通过**使用< noscript>元索，可以指定在浏览器不支持脚本时显示的内容**。如果浏览器支持并启用脚本，则< noscript>元素中的任何内容都不会被渲染。



# 3、语言基础

* 严格模式

~~~JavaScript
function doSomething(){
    "use strict";
    //函数体
}
~~~

* **var/let/const：**

~~~js
//1、var函数作用域 函数的局部变量
function test1(){
    var message = "hi";//局部变量
}
test1();
console.log(message);//出错

//省略var 全局变量 不推荐
function test2(){
    message = "hi";
}
test2();
console.log(message)//"hi"

//2、var变量提升 把所有变量声明都拉到函数作用域的顶部

//let块作用域
if(true){
    let age = 26;
    console.log(age);//26
}
console.log(age)//age没有定义

//1、暂时性死区 let声明的变量不会在作用域中被提升
//2、var声明的变量会成为window对象的属性，let不会
//3、条件声明 不检查是否已声明
//4、let之前，for循环定义的迭代变量会渗透到循环体外部

//const 的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误
~~~

* Number( )函数基于如下规则执行转换:布尔值，true转换为1， false转换为0;数值，直接返回;null，返回0;undefined，返回NaN;字符串，应用规则。

* ECMAScript中的基本数据类型包括Undefined、Null、Boolean 、Number(不区分整数和浮点值) 、String 和Symbol;Object是一种复杂数据类型，它是这门语言中所有对象的基类。
* ECMAScript提供了C语言和类C语言中常见的很多基本操作符,包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。
* ECMAScript中的函数与其他语言中的函数不一样。不指定返回值的函数实际上会返回特殊值undefined。



# 4、变量、作用域与内存

* JavaScript变量可以保存两种类型的值:原始值和引用值。原始值可能是以下6种原始数据类型之一:Undefined、Null、Boolean、Number、String和symbol。原始值和引用值有以下特点。
* 原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。
* 引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
* typeof操作符可以确定值的原始类型，而instanceof操作符用于确保值的引用类型。
* 任何变量（不管包含的是原始值还是引用值)都存在于某个执行上下文中(也称为作用域)。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文分全局上下文、函数上下文和块级上下文。
* 代码执行流每进入一个新**上下文**，都会创建一个作用域链，用于搜索变量和函数。函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。变量的执行上下文用于确定什么时候释放内存。
* JavaScript是使用**垃圾回收**的编程语言，离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
* **引用计数**是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的正仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素)。引用计数在代码中存在循环引用时会出现问题。
* **解除变量的引用**不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。



# 5、基本引用类型

* 引用值与传统面向对象编程语言中的类相似，但实现不同。ECMAScript **缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口**。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
* Date类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。
* RegExp类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。存在**模式局限**(分别匹配字符串的开始和末尾、条件式匹配、正则表达式注释)。
* JavaScript 比较独特的一点是，**函数实际上是Function类型的实例，也就是说函数也是对象**。因为函数也是对象，所以函数也有方法，可以用于增强其能力。
* 由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有3种原始值包装类型:Boolean、Nurmber和 string。它们都具备如下特点。
  * 每种包装类型都映射到同名的原始类型。
  * 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。
  * 涉及原始值的语句执行完毕后，包装对象就会被销毁。
* 当代码开始执行时，全局上下文中会存在两个内置对象:Global和 Math。其中，Global对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为window对象。所有全局变量和函数都是Global对象的属性。Math对象包含辅助完成复杂计算的属性和方法。



# 6、集合引用类型

* JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。引用类型与传统面向对象编程语言中的类相似，但实现不同。
* Object类型是一个基础类型，所有引用类型都从它继承了基本的行为。
* Array类型表示一组有序的值，并提供了操作和转换值的能力。
* 定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。
* ECMAScript6新增了一批引用类型:Map、weakMap、Set和 weakSet。这些类型为组织应用程序数据和简化内存管理提供了新能力。



# 7、迭代器与生成器

* ECMAScript 6正式支持迭代模式并引入了两个新的语言特性:迭代器和生成器。迭代会在一个**有序集合**上进行。(“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是JavaScript中有序集合的最典型例子。
* 迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现itarable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现iterator接口的对象。
* 迭代器必须通过连续调用**naxt()**方法才能连续取得值，这个方法返回一个**Iteratorobject**。这个对象包含一个done 属性和一个value 属性。前者是一个布尔值，表示是否还有更多值可以访问;后者包含迭代器返回的当前值。这个接口可以通过手动反复调用next ()方法来消费，也可以通过原生消费者，比如for-of循环来自动消费。
* 生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了Iterable接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield关键字，这个关键字能够暂停执行生成器函数。使用yield关键字还可以通过next()方法接收输人和产生输出。在加上星号之后，yield关键字可以将跟在它后面的可迭代对象序列化为一连串值。

